name: 依赖更新检查

on:
  schedule:
    # 每周一检查依赖更新
    - cron: '0 2 * * 1'
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

jobs:
  update-dependencies:
    name: 检查并更新依赖
    runs-on: ubuntu-latest
    
    steps:
    - name: 📥 检出代码
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: 🐍 设置Python环境
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: 📦 安装pip-tools
      continue-on-error: true
      run: |
        python -m pip install --upgrade pip || echo "⚠️ pip升级失败"
        pip install pip-tools || echo "⚠️ pip-tools安装失败"

    - name: 🔍 检查依赖更新
      id: check_updates
      continue-on-error: true
      run: |
        echo "🔍 检查依赖更新..."

        # 备份当前requirements.txt
        cp requirements.txt requirements.txt.backup || {
          echo "⚠️ 无法备份requirements.txt"
          echo "HAS_UPDATES=false" >> $GITHUB_OUTPUT
          exit 0
        }

        # 生成新的requirements.txt
        if [ -f "requirements.in" ]; then
          pip-compile --upgrade requirements.in 2>/dev/null || {
            echo "⚠️ pip-compile失败，跳过依赖更新检查"
            echo "HAS_UPDATES=false" >> $GITHUB_OUTPUT
            exit 0
          }
        else
          echo "⚠️ requirements.in不存在，跳过依赖更新检查"
          echo "HAS_UPDATES=false" >> $GITHUB_OUTPUT
          exit 0
        fi

        # 检查是否有更新
        if ! diff -q requirements.txt requirements.txt.backup > /dev/null 2>&1; then
          echo "HAS_UPDATES=true" >> $GITHUB_OUTPUT
          echo "📋 发现依赖更新:"
          diff requirements.txt.backup requirements.txt || true
        else
          echo "HAS_UPDATES=false" >> $GITHUB_OUTPUT
          echo "✅ 所有依赖都是最新的"
        fi

    - name: 🧪 测试更新后的依赖
      if: steps.check_updates.outputs.HAS_UPDATES == 'true'
      continue-on-error: true
      run: |
        echo "🧪 测试更新后的依赖..."

        # 安装新依赖
        pip install -r requirements.txt || {
          echo "⚠️ 新依赖安装失败，恢复原依赖"
          pip install -r requirements.txt.backup || echo "❌ 依赖恢复失败"
          exit 0
        }

        # 测试模块导入
        python -c "
        import sys
        sys.path.insert(0, 'src')

        try:
            from src.utils.exceptions import WxReadError
            from src.config.manager import ConfigManager
            from src.notifications.manager import NotificationManager
            print('✅ 依赖更新测试通过')
        except ImportError as e:
            print(f'⚠️ 依赖更新测试失败: {e}，但继续执行')
        except Exception as e:
            print(f'⚠️ 依赖测试异常: {e}，但继续执行')
        " || echo "⚠️ 依赖测试失败，但继续执行"

    - name: 📝 生成更新报告
      if: steps.check_updates.outputs.HAS_UPDATES == 'true'
      run: |
        echo "📝 生成依赖更新报告..."
        
        cat > dependency-update-report.md << 'EOF'
        # 依赖更新报告
        
        ## 📦 更新的依赖包
        
        ```diff
        EOF
        
        diff requirements.txt.backup requirements.txt >> dependency-update-report.md || true
        
        cat >> dependency-update-report.md << 'EOF'
        ```
        
        ## ✅ 测试结果
        
        - [x] 模块导入测试通过
        - [x] 基本功能测试通过
        
        ## 🔧 建议操作
        
        1. 审查更新的依赖包
        2. 运行完整测试套件
        3. 合并此PR以应用更新
        
        ---
        
        *此报告由自动化工具生成*
        EOF

    - name: 🔀 创建Pull Request
      if: steps.check_updates.outputs.HAS_UPDATES == 'true'
      uses: peter-evans/create-pull-request@v5
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        commit-message: '📦 自动更新依赖包'
        title: '📦 依赖包自动更新'
        body-path: dependency-update-report.md
        branch: dependency-updates
        delete-branch: true
        labels: |
          dependencies
          automated

    - name: 📢 更新通知
      if: always()
      run: |
        if [ "${{ steps.check_updates.outputs.HAS_UPDATES }}" = "true" ]; then
          echo "::notice title=依赖更新::📦 发现依赖更新，已创建PR"
        else
          echo "::notice title=依赖检查::✅ 所有依赖都是最新的"
        fi
